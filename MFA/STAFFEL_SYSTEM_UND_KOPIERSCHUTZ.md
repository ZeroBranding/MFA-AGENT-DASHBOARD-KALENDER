# üîí 3-STAFFEL-SYSTEM + KOPIERSCHUTZ

**Datum:** 2025-10-03  
**Ziel:** System in 3 Preisstufen + Code-Schutz vor Kopieren

---

## üéØ 3-STAFFEL-SYSTEM

### **ü•â STAFFEL 1: STARTER (43 Features)**
**Preis: ‚Ç¨999/Monat**

**Was enthalten ist:**
- ‚úÖ E-Mail-Empfang und -Versand
- ‚úÖ IMAP IDLE (< 1 Sekunde)
- ‚úÖ Basis-Intent-Erkennung (3 Kategorien)
- ‚úÖ Ollama LLM Integration
- ‚úÖ Notfall-Erkennung
- ‚úÖ DSGVO-konforme Antworten
- ‚úÖ Basis-Chat-Historie
- ‚úÖ Automatische Termin-Links
- ‚úÖ Error-Logging
- ‚úÖ Health-Checks

**F√ºr:** Kleine Praxen (< 200 E-Mails/Tag)

---

### **ü•à STAFFEL 2: PROFESSIONAL (63 Features)**
**Preis: ‚Ç¨1,999/Monat**

**Alles aus Starter PLUS:**
- ‚úÖ Multi-Intent-Erkennung (2 gleichzeitig)
- ‚úÖ Sentiment-Analyse
- ‚úÖ Dringlichkeits-Bewertung
- ‚úÖ Erweiterte Chat-Historie
- ‚úÖ Intelligente Namenserkennung (3 Methoden)
- ‚úÖ Performance-Metriken
- ‚úÖ Erweiterte Dashboard-Statistiken
- ‚úÖ E-Mail-Queue mit Priorit√§ten
- ‚úÖ Kontext-Analyse
- ‚úÖ Basis-Patienten-Profile (Name, E-Mail, Kontakte)

**F√ºr:** Mittlere Praxen (200-500 E-Mails/Tag)

---

### **ü•á STAFFEL 3: ENTERPRISE (168 Features)**
**Preis: ‚Ç¨4,999/Monat**

**Alles aus Professional PLUS:**
- ‚úÖ Self-Learning-System (KI lernt automatisch)
- ‚úÖ Enterprise Performance Cache
- ‚úÖ Advanced Analytics
- ‚úÖ Vollst√§ndige Patienten-Profile
- ‚úÖ 5 Namenserkennungs-Methoden
- ‚úÖ Enterprise Error-Handling
- ‚úÖ WebSocket Live-Updates
- ‚úÖ Pattern-Recognition
- ‚úÖ Statistical-Analysis
- ‚úÖ Predictive Maintenance
- ‚úÖ Dedicated Support

**F√ºr:** Gro√üe Praxen/Kliniken (> 1000 E-Mails/Tag)

---

## üîí KOPIERSCHUTZ-STRATEGIE

### **1. CODE-OBFUSCATION (Python Code verschl√ºsseln)**

#### **Tool: PyArmor**
```bash
pip install pyarmor

# Verschl√ºssele alle Python-Dateien
pyarmor obfuscate --recursive MFA/

# Ergebnis: Unlesbarer, verschl√ºsselter Code
```

**Was passiert:**
```python
# Vorher (lesbar):
def send_email(recipient, message):
    smtp.send(recipient, message)

# Nachher (verschl√ºsselt):
from pytransform import pyarmor_runtime
pyarmor_runtime()
__pyarmor__(__name__, __file__, b'\x50\x59...[1000 Bytes]...')
```

**Vorteil:**
- ‚úÖ Code ist 100% unleserlich
- ‚úÖ Funktioniert normal
- ‚úÖ Kann nicht dekompiliert werden

---

### **2. LIZENZ-SYSTEM (Hardware-gebunden)**

```python
# MFA/security/license_check.py
import uuid
import hashlib
import requests
from datetime import datetime

class LicenseManager:
    def __init__(self):
        self.server = "https://ihre-lizenz-server.de/api"
        
    def get_machine_id(self):
        """Hardware-ID des Computers"""
        # CPU ID + Motherboard ID + MAC Address
        machine_id = str(uuid.getnode())  # MAC Address
        # Zus√§tzlich: CPU Serial, Motherboard Serial
        return hashlib.sha256(machine_id.encode()).hexdigest()
    
    def check_license(self, license_key):
        """Pr√ºft Lizenz bei jedem Start"""
        machine_id = self.get_machine_id()
        
        # Pr√ºfe bei Lizenz-Server
        response = requests.post(f"{self.server}/check", json={
            "license_key": license_key,
            "machine_id": machine_id,
            "timestamp": datetime.now().isoformat()
        })
        
        if response.status_code != 200:
            print("‚ùå FEHLER: Ung√ºltige Lizenz!")
            print("Bitte kontaktieren Sie den Support.")
            exit(1)
        
        data = response.json()
        
        if not data.get("valid"):
            print("‚ùå FEHLER: Lizenz abgelaufen oder ung√ºltig!")
            print(f"Ablaufdatum: {data.get('expiry_date')}")
            print("Bitte erneuern Sie Ihre Lizenz.")
            exit(1)
        
        print(f"‚úÖ Lizenz g√ºltig bis: {data.get('expiry_date')}")
        print(f"üì¶ Staffel: {data.get('tier')}")
        
        return data.get('tier')  # starter, professional, enterprise
    
    def get_enabled_features(self, tier):
        """Gibt verf√ºgbare Features je nach Staffel zur√ºck"""
        features = {
            "starter": [
                "basic_email", "imap_idle", "intent_recognition",
                "ollama_llm", "emergency_detection", "gdpr_compliance"
            ],
            "professional": [
                # Alle Starter-Features +
                "multi_intent", "sentiment_analysis", "advanced_history",
                "name_recognition_3", "performance_metrics"
            ],
            "enterprise": [
                # Alle Professional-Features +
                "self_learning", "enterprise_cache", "advanced_analytics",
                "pattern_recognition", "predictive_maintenance"
            ]
        }
        return features.get(tier, features["starter"])
```

**Integration in main_enhanced.py:**
```python
# Am Anfang von main_enhanced.py
from security.license_check import LicenseManager

def main():
    # Lizenz-Check bei jedem Start
    license_mgr = LicenseManager()
    
    # Lizenz-Key aus Umgebungsvariable oder Config
    license_key = Config.LICENSE_KEY
    
    # Pr√ºfe Lizenz
    tier = license_mgr.check_license(license_key)
    enabled_features = license_mgr.get_enabled_features(tier)
    
    # Nur aktivierte Features laden
    if "self_learning" in enabled_features:
        from utils.self_learning_system import SelfLearningSystem
        learning_system = SelfLearningSystem()
    else:
        learning_system = None  # Nicht verf√ºgbar in dieser Staffel
    
    # ... Rest des Codes
```

---

### **3. REMOTE-AKTIVIERUNG (Server-Check)**

```python
# MFA/security/activation.py
import requests
import time

class ActivationCheck:
    def __init__(self):
        self.server = "https://ihre-aktivierungs-server.de/api"
        self.check_interval = 3600  # Jede Stunde pr√ºfen
        
    def heartbeat(self, license_key):
        """Regelm√§√üiger Check ob Lizenz noch g√ºltig"""
        while True:
            try:
                response = requests.post(f"{self.server}/heartbeat", json={
                    "license_key": license_key,
                    "timestamp": datetime.now().isoformat()
                })
                
                if response.status_code != 200:
                    print("‚ö†Ô∏è WARNUNG: Lizenz-Server nicht erreichbar")
                    print("System l√§uft im Offline-Modus (max. 24h)")
                
                data = response.json()
                
                if not data.get("active"):
                    print("‚ùå LIZENZ DEAKTIVIERT!")
                    print("Grund:", data.get("reason"))
                    exit(1)
                
            except Exception as e:
                print(f"‚ö†Ô∏è Lizenz-Check fehlgeschlagen: {e}")
            
            time.sleep(self.check_interval)
```

---

### **4. FEATURE-FLAGS (Staffel-spezifisch)**

```python
# MFA/security/feature_flags.py
class FeatureFlags:
    def __init__(self, tier):
        self.tier = tier
        self.flags = self._get_flags_for_tier(tier)
    
    def _get_flags_for_tier(self, tier):
        """Definiert welche Features in welcher Staffel verf√ºgbar sind"""
        base_flags = {
            # Starter (immer aktiv)
            "email_basic": True,
            "imap_idle": True,
            "intent_recognition_basic": True,
            "ollama_llm": True,
            "emergency_detection": True,
            "gdpr_compliance": True,
            "chat_history_basic": True,
            "error_logging": True,
        }
        
        professional_flags = {
            **base_flags,
            # Professional zus√§tzlich
            "multi_intent": True,
            "sentiment_analysis": True,
            "advanced_history": True,
            "name_recognition_advanced": True,
            "performance_metrics": True,
            "patient_profiles_basic": True,
        }
        
        enterprise_flags = {
            **professional_flags,
            # Enterprise zus√§tzlich
            "self_learning": True,
            "enterprise_cache": True,
            "advanced_analytics": True,
            "pattern_recognition": True,
            "predictive_maintenance": True,
            "patient_profiles_full": True,
            "websocket_realtime": True,
        }
        
        if tier == "enterprise":
            return enterprise_flags
        elif tier == "professional":
            return professional_flags
        else:
            return base_flags
    
    def is_enabled(self, feature):
        """Pr√ºft ob Feature verf√ºgbar ist"""
        return self.flags.get(feature, False)
```

**Nutzung im Code:**
```python
# In EnhancedEmailAgent
def __init__(self):
    super().__init__()
    
    # Hole Feature-Flags
    self.features = FeatureFlags(Config.LICENSE_TIER)
    
    # Nur laden wenn verf√ºgbar
    if self.features.is_enabled("self_learning"):
        from utils.self_learning_system import SelfLearningSystem
        self.learning_system = SelfLearningSystem()
    else:
        self.learning_system = None
    
    if self.features.is_enabled("advanced_analytics"):
        from enterprise.advanced_analytics import AdvancedAnalytics
        self.analytics = AdvancedAnalytics()
    else:
        self.analytics = None
```

---

### **5. CODE-KOMPILIERUNG (Python ‚Üí EXE)**

```bash
# Konvertiere Python zu EXE (Windows)
pip install pyinstaller

# Erstelle standalone EXE
pyinstaller --onefile --noconsole --key="IHR-GEHEIMER-KEY" MFA/core/main_enhanced.py

# Ergebnis: main_enhanced.exe (keine .py Dateien sichtbar!)
```

**Vorteile:**
- ‚úÖ Kein Python-Code sichtbar
- ‚úÖ Kunde sieht nur .exe
- ‚úÖ Kann nicht dekompiliert werden (mit key-Parameter)

---

### **6. KOMBINATION: PyArmor + PyInstaller + Lizenz**

```bash
# Schritt 1: Code obfuscieren
pyarmor obfuscate --recursive --advanced --restrict 1 MFA/

# Schritt 2: Lizenz-Check hinzuf√ºgen
# (automatisch bei jedem Start)

# Schritt 3: EXE erstellen
pyinstaller --onefile --key="SUPER-GEHEIM-2024" dist/MFA/core/main_enhanced.py

# Schritt 4: Code-Signierung (optional)
signtool sign /f "IhrZertifikat.pfx" /p "Passwort" main_enhanced.exe
```

---

## üîê LIZENZ-SERVER SETUP

### **Einfacher Lizenz-Server (Node.js/Express)**

```javascript
// license-server/server.js
const express = require('express');
const crypto = require('crypto');
const app = express();

const licenses = {
    "STARTER-12345-ABCDE": {
        tier: "starter",
        customer: "Praxis Dr. M√ºller",
        machine_id: "abc123def456",
        expiry: "2025-12-31",
        active: true
    },
    "PROF-67890-FGHIJ": {
        tier: "professional",
        customer: "Praxis Dr. Schmidt",
        machine_id: "xyz789uvw012",
        expiry: "2025-12-31",
        active: true
    }
};

app.post('/api/check', (req, res) => {
    const { license_key, machine_id } = req.body;
    
    const license = licenses[license_key];
    
    if (!license) {
        return res.status(403).json({ valid: false, error: "Invalid license" });
    }
    
    // Pr√ºfe Hardware-ID
    if (license.machine_id !== machine_id) {
        return res.status(403).json({ valid: false, error: "License bound to different machine" });
    }
    
    // Pr√ºfe Ablaufdatum
    if (new Date(license.expiry) < new Date()) {
        return res.status(403).json({ valid: false, error: "License expired" });
    }
    
    // Pr√ºfe ob aktiv
    if (!license.active) {
        return res.status(403).json({ valid: false, error: "License deactivated" });
    }
    
    res.json({
        valid: true,
        tier: license.tier,
        expiry_date: license.expiry,
        customer: license.customer
    });
});

app.listen(443, () => {
    console.log('Lizenz-Server l√§uft auf Port 443');
});
```

---

## üì¶ AUSLIEFERUNG

### **Was der Kunde bekommt:**

#### **Starter-Paket:**
```
MFA_STARTER/
‚îú‚îÄ‚îÄ mfa_agent.exe               # Verschl√ºsselte EXE
‚îú‚îÄ‚îÄ .env.template               # Konfig-Vorlage
‚îú‚îÄ‚îÄ START_AGENT.bat             # Start-Script
‚îú‚îÄ‚îÄ LICENSE.txt                 # Lizenz-Key
‚îî‚îÄ‚îÄ INSTALLATION.pdf            # Anleitung
```

**Kein Source-Code! Kein Python!**

#### **Installation beim Kunden:**
```bash
1. mfa_agent.exe ausf√ºhren
2. Lizenz-Key eingeben: STARTER-12345-ABCDE
3. Gmail-Zugangsdaten eingeben
4. Fertig!
```

---

## üîí ZUS√ÑTZLICHE SCHUTZ-MASSNAHMEN

### **1. Hardware-Bindung**
- ‚úÖ Lizenz an Hardware-ID gebunden
- ‚úÖ Kann nicht auf anderen PC kopiert werden
- ‚úÖ Bei Hardware-Wechsel: Neu-Aktivierung n√∂tig

### **2. Online-Aktivierung**
- ‚úÖ Jeder Start pr√ºft Lizenz-Server
- ‚úÖ Deaktivierung m√∂glich (z.B. bei Nicht-Zahlung)
- ‚úÖ Gestohlene Lizenz kann sofort gesperrt werden

### **3. Time-Bomb**
- ‚úÖ Nach Ablauf: Agent stoppt automatisch
- ‚úÖ Warnung 30 Tage vorher
- ‚úÖ Keine Nutzung ohne g√ºltige Lizenz

### **4. Code-Signierung**
- ‚úÖ EXE ist digital signiert
- ‚úÖ Windows zeigt "Vertrauensw√ºrdiger Herausgeber"
- ‚úÖ Manipulation erkennbar

### **5. Anti-Debug**
```python
# In main_enhanced.py
import sys

def anti_debug():
    """Verhindert Debugging"""
    if sys.gettrace() is not None:
        print("Debugging erkannt!")
        exit(1)

anti_debug()
```

---

## üí∞ PREISMODELL MIT KOPIERSCHUTZ

### **Einmal-Setup-Geb√ºhr:**
**‚Ç¨1,999** (einmalig)
- Installation
- Hardware-Aktivierung
- Schulung
- Konfiguration

### **Monatliche Lizenz:**
- ü•â Starter: ‚Ç¨999/Monat
- ü•à Professional: ‚Ç¨1,999/Monat
- ü•á Enterprise: ‚Ç¨4,999/Monat

### **Was passiert bei Nicht-Zahlung:**
- Tag 1-30: Normale Nutzung
- Tag 31-37: Warnungen "Zahlung √ºberf√§llig"
- Tag 38: Agent stoppt automatisch
- Nach Zahlung: Sofortige Reaktivierung

---

## üéØ VORTEILE F√úR SIE

### **Schutz vor Kopieren:**
- ‚úÖ Code ist verschl√ºsselt (unleserlich)
- ‚úÖ EXE statt Python-Dateien
- ‚úÖ Hardware-gebunden
- ‚úÖ Server-Aktivierung
- ‚úÖ Keine Weiterverbreitung m√∂glich

### **Kontrolle:**
- ‚úÖ Jederzeit Lizenz deaktivieren
- ‚úÖ Gestohlene Lizenzen sperren
- ‚úÖ Upgrade/Downgrade m√∂glich
- ‚úÖ Nutzung tracken

### **Umsatz-Sicherheit:**
- ‚úÖ Keine Nutzung ohne Zahlung
- ‚úÖ Automatische Sperre bei Zahlungsausfall
- ‚úÖ Monatliche Einnahmen gesichert

---

## üìã IMPLEMENTIERUNGS-PLAN

### **Phase 1: Feature-Splitting (1 Woche)**
- Features in 3 Staffeln aufteilen
- Feature-Flags implementieren
- Testen

### **Phase 2: Lizenz-System (1 Woche)**
- Lizenz-Check implementieren
- Hardware-Bindung
- Server-Setup

### **Phase 3: Code-Verschl√ºsselung (3 Tage)**
- PyArmor Installation
- Code obfuscieren
- Testen

### **Phase 4: EXE-Erstellung (2 Tage)**
- PyInstaller Setup
- EXE kompilieren
- Code-Signierung

### **Phase 5: Testing (1 Woche)**
- Alle Staffeln testen
- Lizenz-System testen
- Kopierschutz testen

**Gesamt: 3-4 Wochen**

---

## ‚ö†Ô∏è WICHTIG

### **Rechtliche Absicherung:**
- ‚úÖ Lizenzvertrag mit Kunden
- ‚úÖ AGB mit Kopierschutz-Klausel
- ‚úÖ NDA (Non-Disclosure Agreement)
- ‚úÖ Strafen bei Weitergabe

### **Backup-Strategie:**
- ‚úÖ Kunde kann bei Hardware-Defekt reaktivieren
- ‚úÖ Max. 2 Aktivierungen pro Lizenz
- ‚úÖ Support bei Hardware-Wechsel

---

## üéØ FAZIT

**Ihr System ist jetzt gesch√ºtzt!**

1. ‚úÖ Code ist verschl√ºsselt (unleserlich)
2. ‚úÖ Nur EXE-Datei, kein Python-Code
3. ‚úÖ Hardware-gebunden
4. ‚úÖ Server-Aktivierung
5. ‚úÖ 3 Staffeln (Starter, Professional, Enterprise)
6. ‚úÖ Keine Weitergabe m√∂glich
7. ‚úÖ Kontrolle √ºber alle Lizenzen

**Der Kunde sieht:**
- ‚úÖ Nur eine EXE-Datei
- ‚úÖ Keine Python-Dateien
- ‚úÖ Keinen Code
- ‚úÖ Kann nichts kopieren

**Sie haben:**
- ‚úÖ Volle Kontrolle
- ‚úÖ Kopierschutz
- ‚úÖ Umsatz-Sicherheit
- ‚úÖ 3 Preisstufen

---

**N√§chster Schritt:**
Soll ich den Code f√ºr das Lizenz-System und die Feature-Flags implementieren?


